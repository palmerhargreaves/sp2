<?php

ini_set('memory_limit', '1000M');

/**
 * AgreementModelTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class AgreementModelTable extends Doctrine_Table
{
    /**
     * Returns an instance of this class.
     *
     * @return object AgreementModelTable
     */
    const MODEL_BLOCK_DAYS = 11;
    const MODEL_EXTRA_BLOCK_DAYS = 2;

    const MODEL_BLOCKED_ACTIVE = 'active';
    const MODEL_BLOCKED_BLOCKED = 'blocked';

    public static function getInstance()
    {
        return Doctrine_Core::getTable('AgreementModel');
    }

    function hasConcept(Activity $activity, Dealer $dealer)
    {
        return AgreementModelTable::getInstance()
            ->createQuery('m')
            ->innerJoin('m.ModelType mt WITH mt.concept=?', true)
            ->where('m.dealer_id=? and m.activity_id=?', array($dealer->getId(), $activity->getId()))
            ->count() > 0;
    }

    private static function unblockModels($pdo)
    {
        $models = self::getInstance()->createQuery('m')
            ->select('m.id, m.is_blocked')
            ->leftJoin('m.Report r')
            //->where('m.status = ? and r.status != ? ', array('accepted', 'declined'))
            ->andWhere('is_blocked = ?', array(true))
            ->orderBy('m.id ASC')
            ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);
        foreach ($models as $model) {
            $q = "UPDATE agreement_model SET is_blocked = :param1 where id = :param2";
            $smt = $pdo->prepare($q);

            $smt->execute(array('param1' => 0,
                'param2' => $model['id']));
        }
    }

    public function blockModelsIfOutLimitOfWork()
    {
        $pdo = Doctrine_Manager::getInstance()->getCurrentConnection()->getDbh();

        //self::unblockModels($pdo);
        $models = self::getInstance()->createQuery('m')
            //->where('m.is_blocked = ?', false)
            ->select('m.id, m.is_blocked, m.allow_use_blocked, m.use_blocked_to, m.status, r.id, r.status as report_status, v.id, v.value, v.field_id')
            ->leftJoin('m.Report r')
            ->leftJoin('m.Values v')
            ->andWhere('(year(m.created_at) = ? or year(m.created_at) = ?) and m.status != ?', array(date('Y'), date('Y') - 1, 'not_sent'))
            //->andWhere('m.status != ?', array('accepted'))
            ->orderBy('m.id ASC')
            ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);

        $totalBlocked = 0;
        foreach ($models as $model) {
            if (is_null($model['Report']) || (!is_null($model['Report']) && $model['Report']['report_status'] != 'declined')) {
                continue;
            }

            $mustBlocked = self::checkOut($model, $pdo);
            if ($mustBlocked && !$model['is_blocked']) {
                //echo $model->getId()."\r\n";
                $q = "UPDATE agreement_model SET is_blocked = :param1 WHERE id = :param2";
                $smt = $pdo->prepare($q);

                $smt->execute
                (
                    array(
                        'param1' => 1,
                        'param2' => $model['id']
                    )
                );

                $reportId = isset($model['Report']) && isset($model["Report"]["id"]) ? $model["Report"]["id"] : null;
                self::addModelBlockedStatistic($model['id'], $reportId);

                $totalBlocked++;
            }
        }

        return $totalBlocked;
    }

    private static function checkOut($model, $pdo)
    {
        $today = strtotime(date('Y-m-d H:i:s'));

        if ($model['allow_use_blocked'] == 1 && !empty($model['use_blocked_to'])) {
            $blockedDateTo = strtotime($model['use_blocked_to']);

            if ($today > $blockedDateTo) {
                $q = "UPDATE agreement_model SET allow_use_blocked = :param1, use_blocked_to = :param2 WHERE id = :param3";
                $smt = $pdo->prepare($q);

                $smt->execute(
                    array
                    (
                        'param1' => 0,
                        'param2' => '',
                        'param3' => $model['id']
                    )
                );

                $reportId = isset($model['Report']) && isset($model["Report"]["id"]) ? $model["Report"]["id"] : null;
                self::addModelBlockedStatistic($model['id'], $reportId, self::MODEL_BLOCKED_BLOCKED);

                return true;
            }
        }

        /*Если разрешено использовать то проверяем сл.заявку */
        if ($model['allow_use_blocked'] == 1 || $model['status'] == 'wait' || $model['status'] == 'wait_specialist') {
            return false;
        }

        $value = AgreementModelValueTable::getPeriodValueFromModel($model);
        if (!$value) {
            return false;
        }

        $value = self::getNewDate($value, self::MODEL_BLOCK_DAYS);

        $todayDate = strtotime(date('d-m-Y'));
        $lastModelUpdateDate = strtotime($value);

        $elapsed_days = Utils::getElapsedTime($todayDate - $lastModelUpdateDate);
        if ($todayDate >= $lastModelUpdateDate)
        {
            if (!is_null($model['Report']) && $model['Report']['report_status'] == 'declined' && $elapsed_days >= 0) {
                $log_entry = LogEntryTable::getInstance()->createQuery()->select('created_at')->where('object_id = ? and action = ? and object_type = ?', array($model['id'], 'declined', 'agreement_report'))->orderBy('id DESC')->fetchOne(array(), Doctrine_Core::HYDRATE_ARRAY);
                if ($log_entry) {
                    $value = date('d-m-Y', strtotime($log_entry['created_at']));
                }

                $value = self::getNewDate($value, self::MODEL_EXTRA_BLOCK_DAYS);
            }
        }

        $lastModelUpdateDate = strtotime($value);
        if ($todayDate >= $lastModelUpdateDate) {
            return true;
        }

        return false;
    }

    public static function addModelBlockedStatistic($modelId, $reportId, $status = self::MODEL_BLOCKED_BLOCKED, $user_id = -1) {
        $blockedStats = AgreementModelsBlokedStatisticsTable::getInstance()->findOneByModelId($modelId);
        if(!$blockedStats) {
            $blockedStats = new AgreementModelsBlokedStatistics();
            $blockedStats->setArray(
                array(
                    'model_id' => $modelId,
                    'status' => $status
                )
            );
        } else {
            $blockedStats->setStatus($status);
        }
        $blockedStats->save();

        $blockItem = new AgreementModelsBlokedStatisticsItems();
        $blockItem->setArray(
            array(
                'parent_id' => $blockedStats->getId(),
                'type' => $status,
                'user_id' => $user_id,
                'blocked_with_report' => !is_null($reportId) ? true : false
            )
        );

        $blockItem->save();
    }

    static function checkDateInCalendar($date)
    {
        $days = 0;
        $item = CalendarTable::getInstance()->createQuery()
            ->select('start_date, end_date')
            ->where('start_date = ?', date('Y-m-d', strtotime($date)))
            //->andWhere('end_date <= ?', date('Y-m-d', strtotime($date)))
            ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);

        if ($item && isset($item['end_date'])) {
            $endDate = strtotime($item['end_date']);

            $days = 1;
            $i = 1;
            while (1) {
                $tempDate = strtotime(date("Y-m-d", strtotime('+' . $i . ' days', D::toUnix($item['start_date']))));

                if ($tempDate <= $endDate) {
                    $days++;
                    $i++;
                } else
                    break;
            }
        }

        return $days;
    }

    static function getNewDate($date, $plusDays = 3)
    {
        for ($i = 1; $i <= $plusDays; $i++) {
            $tempDate = date("d-m-Y", strtotime('+' . $i . ' days', D::toUnix($date)));
            $d = getdate(strtotime($tempDate));

            $dPlus = self::checkDateInCalendar($tempDate);
            if ($dPlus == 0) {
                if ($d['wday'] == 0 || $d['wday'] == 6)
                    $dPlus++;
            } else if ($dPlus > 1)
                $i += $dPlus;

            $plusDays += $dPlus;
        }

        return date("H:i:s d-m-Y", strtotime('+' . $plusDays . ' days', D::toUnix($date)));
    }

    static function getElapsedDays($st)
    {
        return floor(($st / 3600) / 24);
    }
}