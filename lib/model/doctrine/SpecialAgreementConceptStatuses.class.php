<?php

/**
 * SpecialAgreementConceptStatuses
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    Servicepool2.0
 * @subpackage model
 * @author     Your name here
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class SpecialAgreementConceptStatuses extends BaseSpecialAgreementConceptStatuses
{
    const AGREEMENT_STATUS_NONE = 0;

    //Концепция согласована
    const AGREEMENT_STATUS_REG_MANAGER_ACCEPTED = 1;
    const AGREEMENT_STATUS_IMPORTER_ACCEPTED = 2;

    const AGREEMENT_STATUS_IMPORTER_CANCEL = 3;
    const AGREEMENT_STATUS_REG_MANAGER_CANCEL = 4;

    const AGREEMENT_REPORT_STATUS_IMPORTER_CANCEL = 5;
    const AGREEMENT_REPORT_STATUS_REG_MANAGER_CANCEL = 6;

    //Отчет концепции согласован
    const AGREEMENT_REPORT_STATUS_REG_MANAGER_ACCEPTED = 101;
    const AGREEMENT_REPORT_STATUS_IMPORTER_ACCEPTED = 102;

    //Концепция отклонена
    const AGREEMENT_STATUS_REG_MANAGER_DECLINED = 11;
    const AGREEMENT_STATUS_IMPORTER_DECLINED = 12;

    //Отчет концепции отклонен
    const AGREEMENT_REPORT_STATUS_REG_MANAGER_DECLINED = 110;
    const AGREEMENT_REPORT_STATUS_IMPORTER_DECLINED = 112;

    //Концепция на согласовании
    const AGREEMENT_STATUS_REG_MANAGER_WAIT = 21;
    const AGREEMENT_STATUS_IMPORTER_WAIT = 22;

    //Концепция на согласовании
    const AGREEMENT_REPORT_STATUS_REG_MANAGER_WAIT = 121;
    const AGREEMENT_REPORT_STATUS_IMPORTER_WAIT = 122;

    /**
     * Установить статус выполнения заявки
     * @param $model
     * @param $status
     * @return SpecialAgreementConceptStatuses
     */
    public static function setStatus($model, $status) {
        return self::checkStatusExists($model->getId(), $status);
    }

    /**
     * Получить статус концепции
     * @param $conceptId
     * @return string
     */
    public static function getStatus($conceptId) {
        return self::conceptStatus($conceptId);
    }

    /**
     * Удаление всех статусов у заявки
     * @param $conceptId
     * @internal param $model
     */
    public static function deleteStatuses($conceptId) {
        SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->delete()->where('concept_id = ?', array($conceptId))->execute();
    }

    /**
     * Получить статус отчета концепции
     * @param $conceptId
     * @return string
     */
    public static function getReportStatus($conceptId) {
        //Проверка на выполнение концепции
        if (self::status($conceptId, self::AGREEMENT_REPORT_STATUS_IMPORTER_ACCEPTED) && self::status($conceptId, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_ACCEPTED)) {
            return 'accepted';
        }
        //Проверка на статус выполнения концепции (если хоть у одного пользователя концепция на проверке)
        else if (self::status($conceptId, self::AGREEMENT_REPORT_STATUS_IMPORTER_WAIT) || self::status($conceptId, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_WAIT)) {
            return 'wait';
        }
        //Проверка на статус выполнения концепции (отклоненная заявка, должна быть у об)
        else if (self::status($conceptId, self::AGREEMENT_REPORT_STATUS_IMPORTER_DECLINED) || self::status($conceptId, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_DECLINED)) {
            return 'declined';
        }

        return 'wait';
    }

    /**
     * Проверка на наличие статуса согласования для концепции
     * @param $conceptId
     */
    public static function hasStatus($conceptId) {
        return SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->where('concept_id = ?', array($conceptId))->fetchOne();
    }

    /**
     * Проверка статуса заявки
     * @param $conceptId
     * @param $status
     * @return SpecialAgreementConceptStatuses
     */
    private static function checkStatusExists($conceptId, $status) {
        self::cleanStatuses($conceptId, $status);

        $work_status = SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->where('concept_id = ? and agreement_status = ?', array($conceptId, $status))->fetchOne();
        if (!$work_status) {
            //Создаем статус согласования для рег. менеджера
            $work_status = new SpecialAgreementConceptStatuses();
            $work_status->setArray(array(
                'concept_id' => $conceptId,
            ));
        }

        $work_status->setAgreementStatus($status);
        $work_status->save();

        return self::conceptStatus($conceptId);
    }

    private static function cleanStatuses($conceptId, $status) {
        $importer_statuses = array(self::AGREEMENT_STATUS_NONE, self::AGREEMENT_STATUS_IMPORTER_CANCEL, self::AGREEMENT_STATUS_IMPORTER_WAIT, self::AGREEMENT_STATUS_IMPORTER_DECLINED, self::AGREEMENT_STATUS_IMPORTER_ACCEPTED);
        $reg_manager_statuses = array(self::AGREEMENT_STATUS_NONE, self::AGREEMENT_STATUS_REG_MANAGER_CANCEL, self::AGREEMENT_STATUS_REG_MANAGER_WAIT, self::AGREEMENT_STATUS_REG_MANAGER_DECLINED, self::AGREEMENT_STATUS_REG_MANAGER_ACCEPTED);

        $importer_report_statuses = array(self::AGREEMENT_STATUS_NONE, self::AGREEMENT_REPORT_STATUS_IMPORTER_CANCEL, self::AGREEMENT_REPORT_STATUS_IMPORTER_WAIT, self::AGREEMENT_REPORT_STATUS_IMPORTER_DECLINED, self::AGREEMENT_REPORT_STATUS_IMPORTER_ACCEPTED);
        $reg_manager_report_statuses = array(self::AGREEMENT_STATUS_NONE, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_CANCEL, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_WAIT, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_DECLINED, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_ACCEPTED);

        //Удаляем всю информацию по статусам для импортера
        if (in_array($status, $importer_statuses)) {
            SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->delete()->where('concept_id = ?', $conceptId)->andWhereIn('agreement_status', $importer_statuses)->execute();
        }

        //Отчеты импортера
        if (in_array($status, $importer_report_statuses)) {
            SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->delete()->where('concept_id = ?', $conceptId)->andWhereIn('agreement_status', $importer_report_statuses)->execute();
        }

        //Удаляем всю информацию по статусам для рег.менеджера
        if (in_array($status, $reg_manager_statuses)) {
            SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->delete()->where('concept_id = ?', $conceptId)->andWhereIn('agreement_status', $reg_manager_statuses)->execute();
        }

        //Отчеты рег. менеджера
        if (in_array($status, $reg_manager_report_statuses)) {
            SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->delete()->where('concept_id = ?', $conceptId)->andWhereIn('agreement_status', $reg_manager_report_statuses)->execute();
        }

    }

    /**
     * Проверяем на наличие статуса у концепции
     * @param $conceptId
     * @param $status
     * @return mixed
     */
    public static function status($conceptId, $status) {
        return SpecialAgreementConceptStatusesTable::getInstance()->createQuery()->where('concept_id = ? and agreement_status = ?', array($conceptId, $status))->fetchOne();
    }

    /**
     * Получить статус концепции
     * @param $conceptId
     * @return string
     */
    private static function conceptStatus($conceptId) {
        //Проверка на выполнение концепции
        if (self::status($conceptId, self::AGREEMENT_STATUS_IMPORTER_ACCEPTED) && self::status($conceptId, self::AGREEMENT_STATUS_REG_MANAGER_ACCEPTED)) {
            return 'accepted';
        }
        //Проверка на статус выполнения концепции (если хоть у одного пользователя концепция на проверке)
        else if (self::status($conceptId, self::AGREEMENT_STATUS_IMPORTER_WAIT) || self::status($conceptId, self::AGREEMENT_STATUS_REG_MANAGER_WAIT)) {
            return 'wait';
        }
        //Проверка на статус выполнения концепции (отклоненная заявка, должна быть у об)
        else if (self::status($conceptId, self::AGREEMENT_STATUS_IMPORTER_DECLINED) || self::status($conceptId, self::AGREEMENT_STATUS_REG_MANAGER_DECLINED)) {
            return 'declined';
        }

        return 'wait';
    }

    /**
     * Запрещаем рассылать сообщения пока концепция небудет проверена пользователями
     * @param $conceptId
     * @return bool
     */
    public static function isDirtyConcept($conceptId) {
        //Если есть в ожидании пользователь для проверки концепции, не отображаем сообщения
        if (self::status($conceptId, self::AGREEMENT_STATUS_IMPORTER_WAIT) || self::status($conceptId, self::AGREEMENT_STATUS_REG_MANAGER_WAIT)) {
            return false;
        }

        return true;
    }

    /**
     * Запрещаем рассылать сообщения пока отчет концепции небудет проверен пользователями
     * @param $conceptId
     * @return bool
     */
    public static function isDirtyReportConcept($conceptId) {
        //Если есть в ожидании пользователь для проверки отчета концепции, не отображаем сообщения
        if (self::status($conceptId, self::AGREEMENT_REPORT_STATUS_IMPORTER_WAIT) || self::status($conceptId, self::AGREEMENT_REPORT_STATUS_REG_MANAGER_WAIT)) {
            return false;
        }

        return true;
    }
}
